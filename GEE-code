// Load the country list asset
var countryList = ee.FeatureCollection('projects/ee-guillentorres/assets/country_list');

// Initialize the UI panels
var panel = ui.Panel({style: {width: '300px'}});
var explanation = ui.Label('This app allows you to load the Global Google-Microsoft Open Buildings Dataset, draw an Area of Interest (AOI), and use it to get visual leads to spot recent construction using Sentinel-1 data. ' +
  'To use the app, follow these steps:\n' +
  '1. Draw an AOI on the map. Try to keep it relatively small.\n' +
  '2. Select a country from the dropdown.\n' +
  '3. Choose the start and end dates for the analysis. A careful choice of dates will help you get better leads.\n' +
  '4. Click "Analyze" to see the results.\n' +
  'The results will show areas with likely changes, color-coded from green to red, passing through yellow. Click the "show Google Maps link" to get a URL you can copy and paste in your browser.',
  {whiteSpace: 'pre-wrap'});
var explanationVisible = true;

// Button to toggle the visibility of the explanation text
var toggleExplanationButton = ui.Button({
  label: 'Hide/Show Explanation',
  onClick: function() {
    explanationVisible = !explanationVisible;
    explanation.style().set('shown', explanationVisible);
  }
});

// Dropdown to select a country, initially disabled
var countrySelect = ui.Select({
  placeholder: 'Select a country',
  onChange: fetchCountryData,
  disabled: true
});

// Labels and dropdowns for selecting start and end dates
var startDateLabel = ui.Label('Start Date');
var startYearSelect = ui.Select({
  placeholder: 'Select start year',
  onChange: updateStartMonths
});
var startMonthSelect = ui.Select({
  placeholder: 'Select start month',
  onChange: updateStartDays
});
var startDaySelect = ui.Select({
  placeholder: 'Select start day'
});
var endDateLabel = ui.Label('End Date');
var endYearSelect = ui.Select({
  placeholder: 'Select end year',
  onChange: updateEndMonths
});
var endMonthSelect = ui.Select({
  placeholder: 'Select end month',
  onChange: updateEndDays
});
var endDaySelect = ui.Select({
  placeholder: 'Select end day'
});

// Label and dropdown for selecting the type of analysis (construction or destruction)
var analysisTypeLabel = ui.Label('Analysis Type');
var analysisTypeSelect = ui.Select({
  items: [
    {label: 'Construction', value: 'construction'},
    {label: 'Destruction', value: 'destruction'}
  ],
  value: 'construction'
});

// Buttons for starting analysis, resetting the app, and showing Google Maps link
var analyzeButton = ui.Button('Analyze', analyze);
var messageLabel = ui.Label('');
var resetButton = ui.Button('Reset', resetApp);
var showMapLinkButton = ui.Button('Show Google Maps Link', showGoogleMapsLink);
var googleMapsLinkLabel = ui.Label('', {shown: false});

// Add a gradient legend to the UI
var legendPanel = ui.Panel({
  layout: ui.Panel.Layout.flow('vertical'),
  style: {stretch: 'horizontal', margin: '8px 0'}
});

// Thumbnail for the gradient legend image, with colors from green to red
var gradientImage = ui.Thumbnail({
  image: ee.Image.pixelLonLat().select(0),
  params: {
    bbox: [0, 0, 1, 0.1],
    dimensions: '300x20',  // Adjusted dimensions for larger gradient
    format: 'png',
    min: 0,
    max: 1,
    palette: ['green', 'yellow', 'red']
  },
  style: {stretch: 'horizontal', margin: '8px 0'}
});

// Labels for the legend indicating the range of changes
var legendLabels = ui.Panel({
  layout: ui.Panel.Layout.flow('horizontal'),
  style: {stretch: 'horizontal'}
});
var legendLabelMin = ui.Label('Minimal change', {fontSize: '12px'});
var legendLabelMid = ui.Label('Moderate change', {fontSize: '12px'});
var legendLabelMax = ui.Label('Substantial change', {fontSize: '12px'});

// Add labels to the legend
legendLabels.add(legendLabelMin);
legendLabels.add(ui.Label('', {stretch: 'horizontal'})); // Spacer
legendLabels.add(legendLabelMid);
legendLabels.add(ui.Label('', {stretch: 'horizontal'})); // Spacer
legendLabels.add(legendLabelMax);

// Add the gradient image and labels to the legend panel
legendPanel.add(gradientImage);
legendPanel.add(legendLabels);

// Add elements to the main panel
panel.add(ui.Label({value: 'Search for visual leads of recent construction or destruction', style: {fontWeight: 'bold'}}));
panel.add(toggleExplanationButton);
panel.add(explanation);
panel.add(ui.Label('Draw an AOI to enable country selection.'));
panel.add(countrySelect);
panel.add(startDateLabel);
panel.add(startYearSelect);
panel.add(startMonthSelect);
panel.add(startDaySelect);
panel.add(endDateLabel);
panel.add(endYearSelect);
panel.add(endMonthSelect);
panel.add(endDaySelect);
panel.add(analysisTypeLabel);
panel.add(analysisTypeSelect);
panel.add(analyzeButton);
panel.add(resetButton);
panel.add(showMapLinkButton);
panel.add(googleMapsLinkLabel);
panel.add(messageLabel);
panel.add(legendPanel);

// Initialize map and add the panel to the map
var map = ui.Map();
ui.root.clear();
ui.root.add(panel);
ui.root.add(map);

// Center the map on Mariupol, Ukraine
map.setCenter(37.6173, 47.0951, 12); // Centering the map on Mariupol, Ukraine

// Initialize drawing tools for the map
var drawingTools = map.drawingTools();
drawingTools.setShown(true);
drawingTools.layers().reset();
drawingTools.setDrawModes(['polygon', 'rectangle']);
drawingTools.onDraw(function(geometry) {
  countrySelect.setDisabled(false);  // Enable country selection after AOI is drawn
  console.log('AOI drawn:', geometry);
});

// Debugging: Log UI Initialization
console.log('UI initialized.');

// Function to fetch country data (currently a placeholder)
function fetchCountryData() {
  // No additional functionality needed here for now
}

// Load and sort country data, then populate the country dropdown
countryList.aggregate_array('Country').evaluate(function(names) {
  if (names) {
    names = names.sort();
    countrySelect.items().reset(names.map(function(name) {
      return {
        label: name,
        value: name
      };
    }));
    // Debugging: Log Country Data Loaded
    console.log('Country data loaded:', names);
  } else {
    showError('Error: Country names are undefined.');
  }
});

// Fetch available years for the date selectors
function fetchAvailableYears() {
  var years = ee.List.sequence(2015, 2024).getInfo();
  startYearSelect.items().reset(years.map(function(year) {
    return {label: year.toString(), value: year.toString()};
  }));
  endYearSelect.items().reset(years.map(function(year) {
    return {label: year.toString(), value: year.toString()};
  }));
}

// Update months based on the selected start year
function updateStartMonths() {
  var year = startYearSelect.getValue();
  if (year) {
    var months = ee.List.sequence(1, 12).getInfo();
    startMonthSelect.items().reset(months.map(function(month) {
      return {label: month.toString(), value: month.toString()};
    }));
    console.log('Start year selected:', year);
  }
}

// Update months based on the selected end year
function updateEndMonths() {
  var year = endYearSelect.getValue();
  if (year) {
    var months = ee.List.sequence(1, 12).getInfo();
    endMonthSelect.items().reset(months.map(function(month) {
      return {label: month.toString(), value: month.toString()};
    }));
    console.log('End year selected:', year);
  }
}

// Update days based on the selected start year and month
function updateStartDays() {
  var year = parseInt(startYearSelect.getValue(), 10);
  var month = parseInt(startMonthSelect.getValue(), 10);
  var country = countrySelect.getValue();
  var aoi = drawingTools.layers().get(0).getEeObject();

  if (year && month && country && aoi) {
    var startDate = ee.Date.fromYMD(year, month, 1);
    var endDate = startDate.advance(1, 'month');
    var sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
      .filterBounds(aoi)
      .filterDate(startDate, endDate)
      .filter(ee.Filter.eq('instrumentMode', 'IW'))
      .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
      .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
      .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));
      
    sentinel1.aggregate_array('system:time_start').evaluate(function(dates) {
      var days = dates.map(function(date) {
        return ee.Date(date).getRelative('day', 'month').getInfo() + 1;
      });
      startDaySelect.items().reset(days.map(function(day) {
        return {label: day.toString(), value: day.toString()};
      }));
      console.log('Available days for start date:', days);
    });
  }
}

// Update days based on the selected end year and month
function updateEndDays() {
  var year = parseInt(endYearSelect.getValue(), 10);
  var month = parseInt(endMonthSelect.getValue(), 10);
  var country = countrySelect.getValue();
  var aoi = drawingTools.layers().get(0).getEeObject();

  if (year && month && country && aoi) {
    var startDate = ee.Date.fromYMD(year, month, 1);
    var endDate = startDate.advance(1, 'month');
    var sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
      .filterBounds(aoi)
      .filterDate(startDate, endDate)
      .filter(ee.Filter.eq('instrumentMode', 'IW'))
      .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
      .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
      .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));
      
    sentinel1.aggregate_array('system:time_start').evaluate(function(dates) {
      var days = dates.map(function(date) {
        return ee.Date(date).getRelative('day', 'month').getInfo() + 1;
      });
      endDaySelect.items().reset(days.map(function(day) {
        return {label: day.toString(), value: day.toString()};
      }));
      console.log('Available days for end date:', days);
    });
  }
}

// Define the Sentinel-1 collection function with orbit filtering
function filter_s1(paths, startDate, endDate, aoi) {
  var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
    .filter(ee.Filter.eq('instrumentMode', 'IW'))
    .filter(ee.Filter.inList('orbitProperties_pass', paths))
    .filterDate(startDate, endDate)
    .filterBounds(aoi)
    .select(['VV', 'VH']);  // Select both VV and VH polarizations

  var orbit = s1.aggregate_array('relativeOrbitNumber_start').reduce(ee.Reducer.mode());
  s1 = s1.filter(ee.Filter.eq('relativeOrbitNumber_start', orbit));
  
  return s1;
}

// Function to get the mean, standard deviation, and count of images for a period
function getStats(collection, aoi) {
  var images = collection.filterBounds(aoi);
  var meanImageVV = images.select('VV').mean().clip(aoi);
  var meanImageVH = images.select('VH').mean().clip(aoi);
  var stdDevImageVV = images.select('VV').reduce(ee.Reducer.stdDev()).clip(aoi);
  var stdDevImageVH = images.select('VH').reduce(ee.Reducer.stdDev()).clip(aoi);
  var count = ee.Number(images.size());
  return {
    meanVV: meanImageVV,
    meanVH: meanImageVH,
    stdDevVV: stdDevImageVV,
    stdDevVH: stdDevImageVH,
    count: count
  };
}

// Apply Gaussian smoothing to an image
function applyGaussianSmoothing(image, radius) {
  var gaussianKernel = ee.Kernel.gaussian({
    radius: radius,
    sigma: radius / 3,
    units: 'meters',
    normalize: true
  });
  return image.convolve(gaussianKernel);
}

// Fetch Sentinel-1 Data for a given AOI and date range
function fetchSentinel1Data(aoi, startDate, endDate) {
  console.log('Fetching Sentinel-1 data for AOI:', aoi, 'Start date:', startDate, 'End date:', endDate);

  var paths = ['ASCENDING', 'DESCENDING'];
  var s1 = filter_s1(paths, startDate, endDate, aoi);
  // Debugging: Log Sentinel-1 Data Fetch Status
  console.log('Sentinel-1 data fetched:', s1);

  return s1;
}

// Function to fetch only five images before the start and end dates
function fetchFiveImages(collection, date) {
  var filtered = collection.filterDate('2015-01-01', date).sort('system:time_start', false);
  var limited = filtered.limit(5);
  return limited;
}

// Compute T-Scores for change detection
function computeTScores(sentinel1, aoi, analysisType) {
  console.log('Computing T-scores for Sentinel-1 data');

  // Get the dates for splitting
  var dates = ee.List(sentinel1.aggregate_array('system:time_start')).map(function(d) {
    return ee.Date(d);
  });
  var startDate = ee.Date(dates.sort().get(0));
  var midDate = ee.Date(dates.sort().get(ee.Number(dates.size()).divide(2).floor()));
  var endDate = ee.Date(dates.sort().get(dates.size().subtract(1)));

  var before = fetchFiveImages(sentinel1, midDate);
  var after = fetchFiveImages(sentinel1, endDate);

  var beforeStats = getStats(before, aoi);
  var afterStats = getStats(after, aoi);

  var diffVV = afterStats.meanVV.subtract(beforeStats.meanVV);
  var diffVH = afterStats.meanVH.subtract(beforeStats.meanVH);

  var stdDevVV = beforeStats.stdDevVV;
  var stdDevVH = beforeStats.stdDevVH;

  var tScoreVV = diffVV.divide(stdDevVV);
  var tScoreVH = diffVH.divide(stdDevVH);

  var tScore = tScoreVV.add(tScoreVH).divide(2);

  if (analysisType === 'destruction') {
    tScore = tScore.multiply(-1);
  }

  // Debugging: Log T-Scores Computed
  console.log('T-scores computed:', tScore);

  return tScore;
}

// Clip T-Score image to the AOI
function clipToAOI(image, aoi) {
  console.log('Clipping T-score image to AOI');
  var clippedImage = image.clip(aoi);
  // Debugging: Log Clipped Image
  console.log('Clipped T-score image:', clippedImage);
  return clippedImage;
}

// Assign T-Scores to buildings within the AOI
function assignTScoresToBuildings(tScoreImage, aoi, country) {
  console.log('Assigning T-scores to buildings in AOI for country:', country);

  var buildings;
  if (country === 'Palestine, State of') {
    buildings = ee.FeatureCollection('projects/ee-guillentorres/assets/PSE_polygons');
  } else {
    var datasetPath = 'projects/sat-io/open-datasets/VIDA_COMBINED/' + country;
    buildings = ee.FeatureCollection(datasetPath).filterBounds(aoi);
  }

  var buildingScores = buildings.map(function(building) {
    var meanTScore = tScoreImage.reduceRegion({
      reducer: ee.Reducer.mean(),
      geometry: building.geometry(),
      scale: 10
    }).get('VV');

    return building.set('meanTScore', meanTScore);
  });

  // Debugging: Log Building Scores
  console.log('Building scores assigned:', buildingScores);

  return buildingScores;
}

// Visualize results on the map
function visualizeResults(buildingScores) {
  console.log('Visualizing results');

  var palette = ['green', 'yellow', 'red'];

  var image = ee.Image().float().paint(buildingScores, 'meanTScore');
  var visParams = {
    min: -30,
    max: 30,
    palette: palette
  };

  // Clear previous layers
  map.layers().reset();

  // Add the new layer
  map.layers().set(0, ui.Map.Layer(image, visParams, 'T-Scores'));

  // Debugging: Log Visualization
  console.log('Results visualized on the map');
}

// Analyze function to start the analysis process
function analyze() {
  console.log('Starting analysis');

  var aoi = drawingTools.layers().get(0).getEeObject();

  if (!aoi) {
    showError('Please draw an AOI first.');
    print('Error: No AOI drawn');
    return;
  }

  var country = countrySelect.getValue();
  var startYear = startYearSelect.getValue();
  var startMonth = startMonthSelect.getValue();
  var startDay = startDaySelect.getValue();
  var endYear = endYearSelect.getValue();
  var endMonth = endMonthSelect.getValue();
  var endDay = endDaySelect.getValue();
  var analysisType = analysisTypeSelect.getValue();

  if (!country) {
    showError('Please select a country.');
    print('Error: No country selected');
    return;
  }

  if (!startYear || !startMonth || !startDay || !endYear || !endMonth || !endDay) {
    showError('Please select valid start and end dates.');
    print('Error: Invalid date selection');
    return;
  }

  var startDate = ee.Date.fromYMD(parseInt(startYear, 10), parseInt(startMonth, 10), parseInt(startDay, 10));
  var endDate = ee.Date.fromYMD(parseInt(endYear, 10), parseInt(endMonth, 10), parseInt(endDay, 10));

  // Clear AOI after analysis
  drawingTools.layers().reset();

  // Check if the selected country is "Palestine, State of" and use the appropriate dataset
  if (country === 'Palestine, State of') {
    showLoading('Fetching data and running analysis...');
    console.log('AOI:', aoi);
    console.log('Country:', country);
    console.log('Start Date:', startDate);
    console.log('End Date:', endDate);

    var sentinel1 = fetchSentinel1Data(aoi, startDate, endDate);
    var tScores = computeTScores(sentinel1, aoi, analysisType);
    var clippedTScores = clipToAOI(tScores, aoi);
    var buildingScores = assignTScoresToBuildings(clippedTScores, aoi, 'Palestine, State of');

    // Filter buildings based on T-scores
    var filteredBuildings = analysisType === 'destruction' ?
      buildingScores.filter(ee.Filter.lt('meanTScore', 0)) :
      buildingScores.filter(ee.Filter.gt('meanTScore', 0));

    visualizeResults(filteredBuildings);

    hideLoading();
    console.log('Analysis completed for Palestine, State of');
  } else {
    // Fetch the country ISO code
    countryList.filter(ee.Filter.eq('Country', country)).first().get('ISO').evaluate(function(countryISO) {
      if (!countryISO) {
        showError('Error: ISO code for the selected country not found.');
        return;
      }

      showLoading('Fetching data and running analysis...');
      console.log('AOI:', aoi);
      console.log('Country:', country);
      console.log('Country ISO:', countryISO);
      console.log('Start Date:', startDate);
      console.log('End Date:', endDate);

      var sentinel1 = fetchSentinel1Data(aoi, startDate, endDate);
      var tScores = computeTScores(sentinel1, aoi, analysisType);
      var clippedTScores = clipToAOI(tScores, aoi);
      var buildingScores = assignTScoresToBuildings(clippedTScores, aoi, countryISO);

      // Filter buildings based on T-scores
      var filteredBuildings = analysisType === 'destruction' ?
        buildingScores.filter(ee.Filter.lt('meanTScore', 0)) :
        buildingScores.filter(ee.Filter.gt('meanTScore', 0));

      visualizeResults(filteredBuildings);

      hideLoading();
      console.log('Analysis completed');
    });
  }
}

// Show Google Maps link centered on the current map view
function showGoogleMapsLink() {
  var center = map.getCenter();
  center.evaluate(function(center) {
    var zoom = map.getZoom();
    var url = 'https://www.google.com/maps/@' + center.coordinates[1] + ',' + center.coordinates[0] + ',' + zoom + 'z';
    googleMapsLinkLabel.setValue('');
    panel.remove(googleMapsLinkLabel);
    googleMapsLinkLabel = ui.Label({
      value: 'Open in Google Maps',
      style: {color: 'blue', textDecoration: 'underline'},
      targetUrl: url
    });
    panel.add(googleMapsLinkLabel);
    googleMapsLinkLabel.style().set('shown', true);
  });
}

// Show error messages to the user
function showError(message) {
  messageLabel.setValue(message);
  messageLabel.style().set('color', 'red');
  print('Error:', message);
}

// Show loading messages to the user
function showLoading(message) {
  messageLabel.setValue(message);
  messageLabel.style().set('color', 'black');
  console.log('Loading:', message);
}

// Hide loading messages
function hideLoading() {
  messageLabel.setValue('');
  console.log('Loading finished');
}

// Reset the application to its initial state
function resetApp() {
  console.log('Resetting application to initial state');

  // Clear drawing tools
  drawingTools.layers().reset();
  drawingTools.setDrawModes(['polygon', 'rectangle']);
  countrySelect.setDisabled(true);

  // Reset UI elements
  countrySelect.setValue(null, false);
  startYearSelect.setValue(null, false);
  startMonthSelect.setValue(null, false);
  startDaySelect.setValue(null, false);
  endYearSelect.setValue(null, false);
  endMonthSelect.setValue(null, false);
  endDaySelect.setValue(null, false);

  // Clear map layers
  map.layers().reset();

  // Clear message label
  messageLabel.setValue('');
}

// Fetch available years when the app initializes
fetchAvailableYears();
